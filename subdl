#!/usr/bin/env python3

import os
import gzip
import base64
import struct
import logging

from argparse import ArgumentParser, Action
from xmlrpc.client import ServerProxy


logger = logging.getLogger('simplesubdl')
logger.setLevel(logging.INFO)
logging.basicConfig(level=logging.INFO)


def hash_file(filename):
    """
    Hashes the file passed. Uses OpenSubtitles implementation

    Adapted from:
        https://trac.opensubtitles.org/projects/opensubtitles/wiki/HashSourceCodes#Python
    """
    longlongformat = '<Q'
    bytesize = struct.calcsize(longlongformat)
    assert bytesize == 8

    filesize = os.path.getsize(filename)
    hash_val = filesize

    if filesize < 65536 * 2:
        raise Exception('Error hashing %s: file too small' % filename)

    with open(filename, 'rb') as f:
        for x in range(int(65536 / bytesize)):
            hash_val += struct.unpack(longlongformat, f.read(bytesize))[0]
            hash_val &= 0xFFFFFFFFFFFFFFFF

        # go to end of file
        f.seek(filesize - 65536, 0)

        for x in range(int(65536 / bytesize)):
            hash_val += struct.unpack(longlongformat, f.read(bytesize))[0]
            hash_val &= 0xFFFFFFFFFFFFFFFF

    return '%016x' % hash_val


class OpenSubServer(ServerProxy):
    """ Server class to talk to OpenSubtitles server """

    URI = 'https://api.opensubtitles.org/xml-rpc'
    AGENT = 'TemporaryUserAgent'  # For developing, it may change sometime

    def __init__(self, user, passw, langs):
        """ Instantiates class """
        super(OpenSubServer, self).__init__(OpenSubServer.URI)
        self.user = user
        self.passw = passw
        self.langs = langs

    def login(self):
        """ Tries to log in. Raises `RuntimeError` when it fails """
        login = self.LogIn(self.user, self.passw, 'en', self.AGENT)

        if login['status'] != '200 OK':
            raise RuntimeError('Failed to log in: %s' % login['status'])

        self.token = login['token']
        return self.token

    def languages(self):
        """ Gets all languages available in the website """
        return self.GetSubLanguages('')['data']

    def by_hash(self, filename):
        """ Search by hash for the languages """
        # File info
        movie_hash = hash_file(filename)
        movie_size = os.path.getsize(filename)

        # Create arguments
        search_args = [{
            'sublanguageid': ','.join(self.langs),
            'moviehash': movie_hash,
            'moviebytesize': str(movie_size)
        }]

        # Fetch data
        return self.SearchSubtitles(self.token, search_args)['data']

#     def search_by_string(self, strings, langs):
#         """ Search by string for the languages """
#         query = ' '.join(strings)
#         search_args = [{
#             'sublanguageid': ','.join(langs),
#             'query': query
#         }]
#         return self.SearchSubtitles(self.token, search_args)['data']

#     def search_by_imdb(self, imdb, langs):
#         """ Search by imdb ID for the languages """
#         the_id = re.findall(r'(t+)?(\d+)', imdb)[0][1]
#         search_args = [{
#             'sublanguageid': ','.join(langs),
#             'imdbid': the_id
#         }]
#         return self.SearchSubtitles(self.token, search_args)['data']

    def _download(self, sub):
        """ Download subtitle from the sub dict returned form server """
        sub_id = sub['IDSubtitleFile']
        result = self.DownloadSubtitles(self.token, [sub_id])

        # Decompress it
        compressed_sub = result['data'][0]['data']
        decoded_sub = base64.b64decode(compressed_sub)
        unzipped_sub = gzip.decompress(decoded_sub)

        # To string
        sub_encoding = sub['SubEncoding']
        return unzipped_sub.decode(sub_encoding)


class ListLanguagesAction(Action):
    def __call__(self, *args, **kwargs):
        """ Gets a list of languages from the server and prints it """
        server = OpenSubServer('', '', [])

        # Sort by language id
        languages = server.languages()
        languages = sorted(languages, key=lambda l: l['SubLanguageID'])

        # Print all
        for lang in languages:
            lang_id = lang['SubLanguageID']
            lang_name = lang['LanguageName']
            print('%s\t%s' % (lang_id, lang_name))

        # Exit gracefully
        raise SystemExit


def _create_parser():
    """ Creates parser for CLI """
    parser = ArgumentParser(
        description=(
            'simplesubdl is a program to easily help you download subtitles '
            'for any video file you have. It does everything automatically.'
            'It is a simpler version from the, original, `subdl`. This one is '
            'a rewrite. It uses native python modules to do most of the work. '
            'For example, argument parsing and the server interatction'
        )
    )
    parser.add_argument(
        'files',
        help='Video files to operate on',
        nargs='+'
    )
    parser.add_argument(
        '--version',
        help='Print version and exit',
        action='version',
        version='alpha'
    )
    parser.add_argument(
        '--lang',
        nargs='+',
        help=(
            'Language, in 3 letter codes. Eg. `eng`, `por` or `spa`. Defaults '
            'to %(default)s'
        ),
        default=['eng']
    )
    parser.add_argument(
        '--list-langs',
        help='Lists all languages available and exits',
        action=ListLanguagesAction
    )
    return parser


if __name__ == '__main__':
    parser = _create_parser()
    parsed = parser.parse_args()

    # Create server
    server = OpenSubServer('', '', parsed.lang)
    server.login()

    for file in parsed.files:
        # Get subs data
        subs = server.by_hash(file)

        # No results
        if len(subs) == 0:
            continue

        # Sort by score
        subs = sorted(subs, key=lambda s: s['Score'], reverse=True)

        # Download
        data = server._download(subs[0])

        # Create filename
        filename, _ = os.path.splitext(file)
        filename = f'{filename}.srt'

        # Write
        with open(filename, 'wt') as sub_file:
            sub_file.write(data)
