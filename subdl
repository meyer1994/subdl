#!/usr/bin/env python3

import os
import re
import gzip
import base64
import struct
import logging

from argparse import ArgumentParser, Action, RawTextHelpFormatter
from xmlrpc.client import ServerProxy

NAME = 'subdl'
VERSION = '1.1.0'


def hash_file(name):
    '''
    This function was not changed from the original.

    It was only reformatted. It is based on the version on OpenSubtitles own
    implementation.

    Check:
        http://trac.opensubtitles.org/projects/opensubtitles/wiki/HashSourceCodes

    Args:
        name: Name of the file to hash.

    Returns:
        Base16 hash of the file, in a string.
    '''
    longlongformat = '<Q'
    bytesize = struct.calcsize(longlongformat)
    assert bytesize == 8

    filesize = os.path.getsize(name)
    hash_val = filesize

    if filesize < 65536 * 2:
        raise Exception('Error hashing %s: file too small' % name)

    with open(name, 'rb') as f:
        for x in range(int(65536 / bytesize)):
            hash_val += struct.unpack(longlongformat, f.read(bytesize))[0]
            hash_val &= 0xFFFFFFFFFFFFFFFF

        # go to end of file
        f.seek(filesize - 65536, 0)

        for x in range(int(65536 / bytesize)):
            hash_val += struct.unpack(longlongformat, f.read(bytesize))[0]
            hash_val &= 0xFFFFFFFFFFFFFFFF

    return '%016x' % hash_val


def download(value):
    try:
        return int(value)
    except ValueError:
        pass

    vals = {'first', 'all', 'best-rating', 'most-downloaded', 'query', 'none'}
    if value not in vals:
        raise ValueError('Download value not valid')

    return value


class OpenSubServer(ServerProxy):
    ''' Server class to talk to OpenSubtitles server '''

    URI = 'https://api.opensubtitles.org/xml-rpc'
    AGENT = '%s %s' % (NAME, VERSION)

    def __init__(self, username='', password=''):
        super(OpenSubServer, self).__init__(OpenSubServer.URI)

        logging.info('Logging in %s' % OpenSubServer.URI)
        login = self.LogIn(username, password, 'en', OpenSubServer.AGENT)

        if login['status'] != '200 OK':
            raise RuntimeError('Failed to connect: %s' % login['status'])

        self.token = login['token']

    def search_by_hash(self, filename, langs):
        '''
        Search for the subtitles of passed langs based on the file

        Args:
            filename: File to get the hash and bytesize from
            langs: Languages, in 3-letter code ("eng", "por", for exampĺe).

        Returns:
            List of items from the server.
        '''
        logging.info('Hashing file')
        movie_hash = hash_file(filename)
        logging.debug('Hash: %s' % movie_hash)

        logging.info('Getting file size')
        movie_size = os.path.getsize(filename)
        logging.debug('Size: %d' % movie_size)

        search_args = [{
            'sublanguageid': ','.join(langs),
            'moviehash': movie_hash,
            'moviebytesize': str(movie_size)
        }]
        return self.SearchSubtitles(self.token, search_args)['data']

    def search_by_string(self, strings, langs):
        '''
        Searches subtitles based on a string.

        Args:
            strings: List of items to search.
            langs: Languages, in 3-letter code ("eng", "por", for exampĺe).

        Returns:
            List of items from the server.
        '''
        query = ' '.join(strings)
        search_args = [{
            'sublanguageid': ','.join(langs),
            'query': query
        }]
        logging.info('Searching for query "%s"' % query)
        return self.SearchSubtitles(self.token, search_args)['data']

    def search_by_imdb(self, imdb, langs):
        '''
        Search for subtitles based on IMDB id.

        Args:
            imdb: It can be an IMDB link, id, partial link etc.
            langs: Languages, in 3-letter code ("eng", "por", for exampĺe).

        Returns:
            List of items returned from the server.
        '''
        the_id = re.findall(r'(t+)?(\d+)', imdb)[0][1]
        search_args = [{
            'sublanguageid': ','.join(langs),
            'imdbid': the_id
        }]
        logging.info('Searching for IMDB id %s' % the_id)
        return self.SearchSubtitles(self.token, search_args)['data']

    def download_sub(self, sub):
        '''
        Downloads the passed sub id and returns it as a string

        Args:
            sub: Subtitle object returned by the server. It is used to get the
            ID of the sub to download, and the encoding to use.
        '''
        # donwloads
        sub_id = sub['IDSubtitleFile']
        logging.info('Downloading sub %s' % sub_id)
        result = self.DownloadSubtitles(self.token, [sub_id])
        compressed_sub = result['data'][0]['data']

        # decodes
        logging.info('Decoding sub %s' % sub_id)
        decoded_sub = base64.b64decode(compressed_sub)

        # unzips
        logging.info('Unzipping sub %s' % sub_id)
        unzipped_sub = gzip.decompress(decoded_sub)

        # encodes
        sub_encoding = sub['SubEncoding']
        logging.info('Encoding sub %s to %s' % (sub_id, sub_encoding))
        return unzipped_sub.decode(sub_encoding)

    def get_languages(self, lang=''):
        ''' Gets all languages available in the website '''
        return self.GetSubLanguages(lang)['data']


class ListLanguagesAction(Action):
    def __call__(self, *args, **kwargs):
        ''' Gets a list of languages from the server and prints it '''
        server = OpenSubServer()
        logging.info('Getting languages from server')
        languages = server.get_languages()
        for lang in languages:
            lang_id = lang['SubLanguageID']
            lang_name = lang['LanguageName']
            print('%s\t%s' % (lang_id, lang_name))
        raise SystemExit


def _create_parser():
    ''' Creates parser for CLI '''
    parser = ArgumentParser(
        description=(
            'Subdl is a command-line tool for downloading subtitles from '
            'opensubtitles.org.'
            '\n\n'
            'By default, it will search for English subtitles, display the '
            'results, download the highest-rated result in the requested '
            'language and save it to the appropriate filename.'
        ),
        formatter_class=RawTextHelpFormatter)
    parser.add_argument(
        'files',
        help='video files to download subtitles for. You may use globs',
        nargs='+')
    parser.add_argument(
        '--version',
        help='print version and exit',
        action='version',
        version='%s %s' % (NAME, VERSION))
    parser.add_argument(
        '--lang',
        nargs='+',
        help=(
            'languages in 3-letter code. For example: "eng por spa". Use '
            '"all"for all languages. Defaults to "eng"'
        ),
        default=['eng'])
    parser.add_argument(
        '--list-languages',
        nargs=0,
        action=ListLanguagesAction,
        help='list available languages adn exit')
    parser.add_argument(
        '--username',
        metavar='USER',
        help='opensubtitles.org username. Defaults to ""',
        default='')
    parser.add_argument(
        '--password',
        metavar='PASS',
        help='opensubtitles.org password. Defaults to ""',
        default='')
    parser.add_argument(
        '--search',
        nargs=1,
        help='use search string to look for subtitles')
    parser.add_argument(
        '--download',
        nargs=1,
        help=(
            'ID: Download a particular subtitle by numeric ID\n'
            'first: Download the first search result [default]\n'
            'all: Download all search results\n'
            'best-rating: Download the result with best rating\n'
            'most-downloaded: Download the most downloaded result\n'
            'query: Query which search result to download\n'
            'none: Display search results and exit\n'
        ),
        type=download,
        default='first')
    parser.add_argument(
        '--output',
        help=(
            'Output to specified output filename.  Can include the\n'
            'following format specifiers:\n'
            '{I} subtitle id\n'
            '{m} movie file base     {M} movie file extension\n'
            '{s} subtitle file base  {S} subtitle file extension\n'
            '{l} language (English)  {L} language (2-letter ISO639)\n'
            'Default is "{m}.{S}"; if multiple languages are searched,\n'
            'then the default is "{m}.{L}.{S}"; if --download=all, then\n'
            'the default is "{m}.{L}.{I}.{S}"'))
    parser.add_argument(
        '--existing',
        metavar='ACTION',
        nargs=1,
        help=(
            'abort: Abort if output filename already exists [default]\n'
            'bypass: Exit gracefully if output filename already exists\n'
            'overwrite: Overwrite if output filename already exists\n'
            'query: Query whether to overwrite'))
    parser.add_argument(
        '--imdb-id',
        metavar='ID',
        help='query by IMDB id. Hash is tried first unless --force-imdb')
    parser.add_argument(
        '--force-imdb',
        action='store_true',
        help='force IMDB search. --imdb-id must be specified')
    parser.add_argument(
        '--force-filename',
        action='store_true',
        help='force search using filename')
    parser.add_argument(
        '--filter',
        action='store_true',
        help='filter blacklisted texts from subtitle')
    parser.add_argument(
        '--interactive',
        '-i',
        action='store_true',
        help='equivalent to --download=query --existing=query')

    return parser


if __name__ == '__main__':
    parser = _create_parser()
    options = parser.parse_args()

    server = OpenSubServer(options.username, options.password)
    for file in options.files:
        _, name = os.path.split(file)

        # search
        if options.search is not None:
            result = server.search_by_string(options.search, options.lang)
        # imdb id
        elif options.imdb is not None:
            result = server.search_by_imdb(options.imdb, options.lang)
        # hash
        else:
            result = server.search_by_hash(file, options.lang)

        # no results
        if len(result) == 0:
            logging.info('No results for %s. Continuing...' % name)
            continue

        # best scored
        logging.info('Selecting sub with best score')
        best_scored_sub = max(result, key=lambda s: s['Score'])

        # downloading
        sub_as_string = server.download_sub(best_scored_sub)

        # saving
        path, _ = os.path.splitext(file)
        filename_out = '%s.%s' % (path, best_scored_sub['SubFormat'])
        logging.info('Saving sub to %s' % filename_out)
        with open(filename_out, 'w') as f:
            f.write(sub_as_string)
