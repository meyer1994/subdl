#!/usr/bin/env python3

import os
import io
import gzip
import base64
import struct
import logging

from argparse import ArgumentParser, Action
from xmlrpc.client import ServerProxy

NAME = 'subdl'
VERSION = '1.1.0'


def hash_file(name):
    '''
    This function was not changed from the original.

    It was only reformatted. It is based on the version on OpenSubtitles own
    implementation.

    Check:
        http://trac.opensubtitles.org/projects/opensubtitles/wiki/HashSourceCodes

    Args:
        name: Name of the file to hash.

    Returns:
        Base16 hash of the file, in a string.
    '''
    longlongformat = '<Q'
    bytesize = struct.calcsize(longlongformat)
    assert bytesize == 8

    filesize = os.path.getsize(name)
    hash_val = filesize

    if filesize < 65536 * 2:
        raise Exception('Error hashing %s: file too small' % name)

    with open(name, 'rb') as f:
        for x in range(int(65536 / bytesize)):
            hash_val += struct.unpack(longlongformat, f.read(bytesize))[0]
            hash_val &= 0xFFFFFFFFFFFFFFFF

        # go to end of file
        f.seek(filesize - 65536, 0)

        for x in range(int(65536 / bytesize)):
            hash_val += struct.unpack(longlongformat, f.read(bytesize))[0]
            hash_val &= 0xFFFFFFFFFFFFFFFF

    return '%016x' % hash_val


class OpenSubServer(ServerProxy):
    """docstring for OpenSubServer"""

    URI = 'https://api.opensubtitles.org/xml-rpc'
    AGENT = '%s %s' % (NAME, VERSION)

    def __init__(self, username='', password=''):
        super(OpenSubServer, self).__init__(OpenSubServer.URI)

        logging.info('Logging in %s' % OpenSubServer.URI)
        login = self.LogIn(username, password, 'en', OpenSubServer.AGENT)

        if login['status'] != '200 OK':
            raise RuntimeError('Failed to connect: %s' % login['status'])

        self.token = login['token']

    def search_by_hash(self, filename, lang):
        '''
        Search for the subtitles of passed lang based on the file

        Args:
            filename: File to get the hash and bytesize from
            lang: Language, in 3-letter code ("eng", "por", for exampÄºe).

        Returns:
            List of items from the server.
        '''
        logging.info('Hashing file')
        movie_hash = hash_file(filename)
        logging.info('Hash: %s' % movie_hash)

        logging.info('Getting file size')
        movie_size = os.path.getsize(filename)
        logging.info('Size: %d' % movie_size)

        search_args = [{
            'sublanguageid': lang,
            'moviehash': movie_hash,
            'moviebytesize': str(movie_size)
        }]
        return self.SearchSubtitles(self.token, search_args)['data']

    def download_sub(self, sub):
        '''
        Downloads the passed sub id and returns it as a string

        Args:
            sub: Subtitle object returned by the server. It is used to get the
            ID of the sub to download, and the encoding to use.
        '''
        # donwloads
        sub_id = sub['IDSubtitleFile']
        logging.info('Downloading sub %s' % sub_id)
        result = self.DownloadSubtitles(self.token, [sub_id])
        compressed_sub = result['data'][0]['data']

        # decodes
        logging.info('Decoding sub %s' % sub_id)
        decoded_sub = base64.b64decode(compressed_sub)

        # unzips
        logging.info('Unzipping sub %s' % sub_id)
        with gzip.open(io.BytesIO(decoded_sub)) as gz:
            unzipped_sub = gz.read()

        # encodes
        sub_encoding = sub['SubEncoding']
        logging.info('Encoding sub %s to %s' % (sub_id, sub_encoding))
        return unzipped_sub.decode(sub_encoding)

    def get_languages(self, lang=''):
        ''' Gets all languages available in the website '''
        return self.GetSubLanguages(lang)['data']


class ListLanguagesAction(Action):
    def __call__(self, *args, **kwargs):
        ''' Gets a list of languages from the server and prints it '''
        server = OpenSubServer()
        logging.info('Getting languages from server')
        languages = server.get_languages()
        for lang in languages:
            lang_id = lang['SubLanguageID']
            lang_name = lang['LanguageName']
            print('%s\t%s' % (lang_id, lang_name))
        raise SystemExit


class SetVerbosityAction(Action):
    def __call__(self, nargs=0, *args, **kwargs):
        ''' Simply sets the configuration for the logger '''
        logging.basicConfig(level=logging.INFO, format='%(message)s')


def _create_parser():
    ''' Creates parser for CLI '''
    parser = ArgumentParser(
        description='This is a rewrite of the tool "subdl". It is a simplified'
                    ' version of it. It only searches by hash.')
    parser.add_argument(
        'files',
        help='video files to download subtitles for. You may use globs',
        nargs='+')
    parser.add_argument(
        '--version',
        action='version',
        version='%s %s' % (NAME, VERSION))
    parser.add_argument(
        '--lang',
        help='language in 3-letter code. For example: "eng por spa". Defaults '
             'to %(default)s',
        default='eng')
    parser.add_argument(
        '--list-languages',
        nargs=0,
        action=ListLanguagesAction,
        help='list all the available languages to download')
    parser.add_argument(
        '-v',
        '--verbose',
        nargs=0,
        action=SetVerbosityAction,
        help='set verbosity')
    return parser


if __name__ == '__main__':
    parser = _create_parser()
    options = parser.parse_args()

    server = OpenSubServer()
    for file in options.files:
        _, name = os.path.split(file)

        logging.info('\nSearching movie %s' % name)
        result = server.search_by_hash(file, options.lang)
        logging.info('Found %d subs' % len(result))

        if len(result) == 0:
            logging.info('No results for %s. Continuing...' % name)
            continue

        logging.info('Selecting sub with best score')
        best_scored_sub = max(result, key=lambda s: s['Score'])

        sub_as_string = server.download_sub(best_scored_sub)

        path, _ = os.path.splitext(file)
        filename_out = '%s.%s' % (path, best_scored_sub['SubFormat'])
        logging.info('Saving sub to %s' % filename_out)
        with open(filename_out, 'w') as f:
            f.write(sub_as_string)
